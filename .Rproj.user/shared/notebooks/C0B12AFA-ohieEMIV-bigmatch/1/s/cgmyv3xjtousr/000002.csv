"0","# functions"
"0","##### estLambda: estimates Lambda, provide confidence interval, and p-value"
"0","### FUNCTION: provides point est, confidence interval, and p-value"
"0","### INPUT: Z: instrument (n by 1 vector)"
"0","###        R: response (n by 1 vector)"
"0","###        D: dose (n by 1 vector)"
"0","###        X: covariate matrix (n by p) "
"0","###        matchedNumber: matching vector from matching() function"
"0","###        null: the lambda_0 value in H0: lambda = lambda_0"
"0","###        alphaLevel: alpha level for the confidence interval"
"0","### OUTPUT: point Est, confidence interval, and p-value"
"0","estLambda = function(Z,R,D,X,matchedNumber,null = 0,alphaLevel = 0.05) {"
"0","  if(alphaLevel >= 0.5) stop(""alphaLevel is improperly set"")"
"0","  "
"0","  X.factorize = model.matrix(~X) "
"0","  if(missing(matchedNumber)) matchedNumber = matching(Z,X,""full"")"
"0","  "
"0","  # Deal with non-matched individuals #"
"0","  R.matchedIndiv = R[!is.na(matchedNumber)]"
"0","  D.matchedIndiv = D[!is.na(matchedNumber)]"
"0","  Z.matchedIndiv = Z[!is.na(matchedNumber)]"
"0","  matchedNumber.matchedIndiv = matchedNumber[!is.na(matchedNumber)]"
"0","  "
"0","  # Sort individuals in ascending matching order"
"0","  matchedNumber.sortedIndex = sort(matchedNumber.matchedIndiv,index.return=TRUE)$ix"
"0","  R.sorted = R.matchedIndiv[matchedNumber.sortedIndex]"
"0","  D.sorted = D.matchedIndiv[matchedNumber.sortedIndex]"
"0","  Z.sorted = Z.matchedIndiv[matchedNumber.sortedIndex]"
"0","  matchedNumber.sorted = matchedNumber.matchedIndiv[matchedNumber.sortedIndex]"
"0","  "
"0","  # Calculate the size of each matched set and the corresponding weights"
"0","  ni = tabulate(matchedNumber.sorted); "
"0","  ni = ni[!(ni == 0)] #this cleans up a flaw with matching algorithm "
"0","  #where some matched numbers (e.g. 1:I) are not used between"
"0","  #1 to I"
"0","  I = length(ni)"
"0","  wi = ni^2 / (ni - 1)  #Actual formula: ni^2 /(mi * (ni - mi))"
"0","  "
"0","  # Calculate Vi, Gi, and Hi"
"0","  # Formula"
"0","  # Vi = Gi - lambda * Hi"
"0","  # Gi = wi*(Zij - Zimean)(Rij - Rimean) = wi*(ZijRij - ni*Zmean.*Rmean.)"
"0","  # Hi = wi*(Zij - Zimean)(Dij - Dimean) = wi*(ZijDij - ni*Zmean.*Dmean.)"
"0","  "
"0","  # This requires some thought. Basically, because R,D,Z are all ordered based on matchedset number,"
"0","  # we use cumsum to obtain means of R, D, and Z within each group as well as means of RZ and DZ."
"0","  # The key here is using the cumsum(ni), which keeps track of the indices in all the ordered vectors"
"0","  ni.cumsum = cumsum(ni)"
"0","  RZ.cumsum = cumsum(R.sorted*Z.sorted); DZ.cumsum = cumsum(D.sorted*Z.sorted)"
"0","  R.cumsum = cumsum(R.sorted); D.cumsum = cumsum(D.sorted); Z.cumsum = cumsum(Z.sorted)"
"0","  R.means = (R.cumsum[ni.cumsum] - c(0,R.cumsum[ni.cumsum[-length(ni.cumsum)]]))/ni"
"0","  Z.means = (Z.cumsum[ni.cumsum] - c(0,Z.cumsum[ni.cumsum[-length(ni.cumsum)]]))/ni"
"0","  D.means = (D.cumsum[ni.cumsum] - c(0,D.cumsum[ni.cumsum[-length(ni.cumsum)]]))/ni"
"0","  "
"0","  RZ.group = RZ.cumsum[ni.cumsum] - c(0,RZ.cumsum[ni.cumsum[-length(ni.cumsum)]])"
"0","  DZ.group = DZ.cumsum[ni.cumsum] - c(0,DZ.cumsum[ni.cumsum[-length(ni.cumsum)]])"
"0","  "
"0","  Gi = wi * RZ.group - wi * ni * R.means * Z.means"
"0","  Hi = wi * DZ.group - wi * ni * D.means * Z.means"
"0","  "
"0","  # Compute the point estimate "
"0","  pointEst = sum(Gi) / sum(Hi)"
"0","  "
"0","  # Compute the p-value under the null"
"0","  ViNull = Gi - null * Hi"
"0","  testStatNull = mean(ViNull) / sqrt(1/(I *(I-1)) * sum( (ViNull - mean(ViNull))^2) )"
"0","  pvalue = 2* (1 - pnorm(abs(testStatNull)))"
"0","  "
"0","  # Compute the quadratic terms for CI"
"0","  # A*lambda^2 + B*lambda + C = 0 (technically, it's A*lambda^2 + B*lambda + C <= 0)"
"0","  q = qnorm(1 - alphaLevel/2)"
"0","  A = sum(Hi)^2/I^2 - q^2 /(I * (I-1)) * sum( (Hi - mean(Hi))^2)"
"0","  B = -2 * (sum(Hi) * sum(Gi) / I^2 - q^2 / (I * (I-1)) * sum( (Hi - mean(Hi)) * (Gi - mean(Gi))))"
"0","  C = sum(Gi)^2/I^2 - q^2/(I * (I-1)) * sum( (Gi - mean(Gi))^2)"
"0","  "
"0","  detQuad = round(B^2 - 4*A*C,9) #6 is set for numerical accuracy"
"0","  if( detQuad <= 0) {"
"0","    if(A < 0) {"
"0","      cis = matrix(c(-Inf,Inf),1,2)"
"0","    } else {"
"0","      cis = matrix(c(NA,NA),1,2)"
"0","    } "
"0","  }"
"0","  if(detQuad > 0) {"
"0","    if(A < 0) {"
"0","      up.ci = (-B - sqrt(detQuad))/ (2*A) "
"0","      low.ci = (-B + sqrt(detQuad)) / (2*A) "
"0","      cis = matrix(c(-Inf,low.ci,up.ci,Inf),2,2,byrow=TRUE)"
"0","    } else {"
"0","      low.ci = (-B - sqrt(detQuad))/ (2*A) "
"0","      up.ci = (-B + sqrt(detQuad)) / (2*A) "
"0","      cis = matrix(c(low.ci,up.ci),1,2)"
"0","    }"
"0","  }"
"0","  return(list(pointEst = pointEst,cis = cis,pvalue = pvalue,statistic = mean(ViNull),variance=sqrt(sqrt(1/(I *(I-1)) * sum( (ViNull - mean(ViNull))^2) ) ) ))"
"0","} "
"0","##### estLambdaTable: estimates Lambda across a table of variables, provide confidence interval, and p-value"
"0","### FUNCTION: provides point est, confidence interval, and p-value"
"0","### INPUT: Z: instrument (n by 1 vector)"
"0","###        tableDF: data frame of the table of responses (n by r)"
"0","###        D: dose (n by 1 vector)"
"0","###        X: covariate matrix (n by p) "
"0","###        matchedNumber: matching vector from matching() function"
"0","###        tableDF: data frame containing table variables only"
"0","###        null: the lambda_0 value in H0: lambda = lambda_0"
"0","###        alphaLevel: alpha level for the confidence interval"
"0","### OUTPUT: point Est, confidence interval, and p-value"
"0","estLambdaTable = function(Z,tableDF,D,X,matchedNumber,null = 0,alphaLevel = 0.05) {"
"0","  if(alphaLevel >= 0.5) stop(""alphaLevel is improperly set"")"
"0","  "
"0","  if (class(tableDF) != ""data.frame""){tableDF = as.data.frame(tableDF)}"
"0","  "
"0","  tdfNA <- colnames(tableDF)[colSums(is.na(tableDF)) > 0]  # find which variables have missing values "
"0","  "
"0","  varsWithNA <- tableDF %>% dplyr::select(tdfNA)  # select missing variables"
"0","  "
"0","  # find rows where NA for outcome variable, get pair ID for those rows, "
"0","  # ignore pairs associated with that ID"
"0","  tdfNAid <- lapply(varsWithNA, function(x) which(is.na(x)))  # list of row indices of missingness"
"0","  pairID <- lapply(tdfNAid, function(x) matchedNumber[x])  # list of pair IDs where at least one pair has missing outcome"
"0","  idxPair <- lapply(pairID, function(x) which(matchedNumber %in% x))  # list of row indices of pairs corresponding to a missing outcome value"
"0","  "
"0","  lamList <- list()"
"0","  "
"0","  for (i in colnames(tableDF)) {"
"0","    if (sum(is.na(tableDF[c(i)])) > 0){"
"0","      # print(estLambda(Z=Z[-idxPair[[c(i)]]], "
"0","      #             R=tableDF[-idxPair[[c(i)]],c(i)],"
"0","      #             D=D[-idxPair[[c(i)]]], "
"0","      #             X=as.matrix(X[-idxPair[[c(i)]],]),"
"0","      #             matchedNumber=matchedNumber[-idxPair[[c(i)]]]))"
"0","      tabLam <- estLambda(Z=Z[-idxPair[[c(i)]]], "
"0","                  R=tableDF[-idxPair[[c(i)]],c(i)],"
"0","                  D=D[-idxPair[[c(i)]]], "
"0","                  X=as.matrix(X[-idxPair[[c(i)]],]),"
"0","                  matchedNumber=matchedNumber[-idxPair[[c(i)]]])"
"0","    } else {"
"0","      # print(estLambda(Z=Z, "
"0","      #             R=tableDF[c(i)],"
"0","      #             D=D, "
"0","      #             X=X,"
"0","      #             matchedNumber=matchedNumber))"
"0","      tabLam <- estLambda(Z=Z, "
"0","                  R=tableDF[c(i)],"
"0","                  D=D, "
"0","                  X=X,"
"0","                  matchedNumber=matchedNumber)"
"0","    }"
"0","    lamList[[i]] <- tabLam"
"0","  }"
"0","  return(lamList)"
"0","}"
"0","##### estLambdaEM: estimates group's Lambda, provide confidence interval, and p-value (currently just works for a single binary variable for grouping)"
"0","### FUNCTION: provides point est, confidence interval, and p-value"
"0","### INPUT: Z: instrument (n by 1 vector)"
"0","###        R: response (n by 1 vector)"
"0","###        D: dose (n by 1 vector)"
"0","###        X: covariate matrix (n by p) "
"0","###        Xg: grouping variable (n by 1 vector)"
"0","###        matchedNumber: matching vector from matching() function"
"0","###        null: the lambda_0 value in H0: lambda = lambda_0"
"0","###        alphaLevel: alpha level for the confidence interval"
"0","### OUTPUT: point Est, confidence interval, and p-value from within group"
"0","estLambdaEM = function(Z,R,D,X,Xg,matchedNumber,null = 0,alphaLevel = 0.05){"
"0","  if(alphaLevel >= 0.5) stop(""alphaLevel is improperly set"")"
"0","  "
"0","  X <- as.matrix(X)  # make sure X is a matrix class, not data.frame"
"0","  "
"0","  # handle potential for missing outcomes (dropping observations)"
"0","  if( sum(is.na(R)) > 0 | sum(is.na(Xg)) > 0 ){"
"0","    # find rows where NA for outcome variable, get pair ID for those rows, "
"0","    # ignore pairs associated with that ID"
"0","    # if R or Xg have no missing values, NAid* = integer(0) which doesn't affect indexing"
"0","    "
"0","    # row indices (individuals) having a missing value for outcome and/or Xg"
"0","    NAidR <- which(is.na(R))"
"0","    NAidXg <- which(is.na(Xg))"
"0","    # pair IDs where at least one pair has missing outcome"
"0","    pairIDR <- matchedNumber[NAidR]"
"0","    pairIDXg <- matchedNumber[NAidXg]"
"0","    # row indices of pairs corresponding to a missing outcome value"
"0","    idxPairR <- which(matchedNumber %in% pairIDR)"
"0","    idxPairXg <- which(matchedNumber %in% pairIDXg)"
"0","    # ignore (remove) pairs associated with a missing value"
"0","    R <- R[-c(idxPairR, idxPairXg)]"
"0","    X <- X[-c(idxPairR, idxPairXg),]"
"0","    D <- D[-c(idxPairR, idxPairXg)]"
"0","    Z <- Z[-c(idxPairR, idxPairXg)]"
"0","    Xg <- Xg[-c(idxPairR, idxPairXg)]"
"0","    matchedNumber <- matchedNumber[-c(idxPairR, idxPairXg)]  # no NA as long as a non-matched individual has a missing value in the outcome"
"0","    "
"0","    # count number individuals dropped from analysis"
"0","    nNA <- length(c(idxPairR,idxPairXg))"
"0","  }"
"0","  "
"0","  uMatchedSets = unique(matchedNumber[!is.na(matchedNumber)])  # guarantee no unmatched individuals"
"0","  g1 = numeric(length(uMatchedSets)); g2 = numeric(length(uMatchedSets))"
"0","  for(i in 1:length(uMatchedSets)) { # find which group a pair belongs"
"0","    pairg <- Xg[which(matchedNumber==uMatchedSets[i])]"
"0","    if(mean(pairg) == 0){g1[i] = uMatchedSets[i]}"
"0","    if(mean(pairg) == 1){g2[i] = uMatchedSets[i]}"
"0","      #if(mean(pairX$female_list) == 0.5){stop(print("
"0","      #  paste0('pair not matched on female_list: ', matchedSets[i])))}"
"0","  }"
"0","  g1 <- g1[g1 != 0] # group where binary variable takes 0 value"
"0","  g2 <- g2[g2 != 0] # group where binary variable takes 1 value"
"0","  "
"0","  # which(matchedNumber %in% gi) = indices of pairs in matchedNumber for group i (ie. get indices of matchedNumber for both pairs in group gi)"
"0","  # test H_01: lambda1 = 0 "
"0","  ## be careful that the indexing lines up"
"0","  Zf1 <- Z[which(matchedNumber %in% g1)]"
"0","  Rf1 <- R[which(matchedNumber %in% g1)]"
"0","  Df1 <- D[which(matchedNumber %in% g1)]"
"0","  Xf1 <- X[which(matchedNumber %in% g1),]"
"0","  pairmatchf1 <- matchedNumber[which(matchedNumber %in% g1)]"
"0","  h1Lambda <- estLambda(Z=Zf1,R=Rf1,D=Df1,X=Xf1,pairmatchf1,null=null,alphaLevel=alphaLevel)"
"0","  "
"0","  # test H_02: lambda2 = 0"
"0","  Zf2 <- Z[which(matchedNumber %in% g2)]"
"0","  Rf2 <- R[which(matchedNumber %in% g2)]"
"0","  Df2 <- D[which(matchedNumber %in% g2)]"
"0","  Xf2 <- X[which(matchedNumber %in% g2),]"
"0","  pairmatchf2 <- matchedNumber[which(matchedNumber %in% g2)]"
"0","  h2Lambda <- estLambda(Z=Zf2,R=Rf2,D=Df2,X=Xf2,pairmatchf2,null=null,alphaLevel=alphaLevel)"
"0","  return(list(h1Lambda=h1Lambda, h2Lambda=h2Lambda, nNA=nNA))"
"0","} "
"0","##### balanceCheck "
"0","### FUNCTION: checks the balance of covariates before and after matching"
"0","### INPUT: Z: treatment/control vector (n time 1) "
"0","###        X: covariates (n * p)"
"0","###        pairmatchvec: vector of matches (handles no matches)"
"0","### OUTPUT: a table of standardized differences"
"0","balanceCheck <- function(Z,X,pairmatchvec) {"
"0","  # Before Matching #"
"0","  X.C.BeforeMatch = X[Z == 0,]; X.T.BeforeMatch = X[Z == 1,];"
"0","  overallSD = sqrt(apply(X.C.BeforeMatch,2,var) + apply(X.T.BeforeMatch,2,var)/2)"
"0","  stdDiff.Before = abs((colMeans(X.T.BeforeMatch) - colMeans(X.C.BeforeMatch))/overallSD)"
"0","  # After Matching #"
"0","  matchedSets = unique(pairmatchvec[!is.na(pairmatchvec)]); "
"0","  X.C.AfterMatch = matrix(0,length(matchedSets),ncol(X)); X.T.AfterMatch = matrix(0,length(matchedSets),ncol(X));"
"0","  nTreatedAfterMatch = rep(0,length(matchedSets))"
"0","  for(i in 1:length(matchedSets)) { "
"0","    treatedZ = which(pairmatchvec == matchedSets[i] & Z == 1)"
"0","    controlZ = which(pairmatchvec == matchedSets[i] & Z == 0)"
"0","    X.C.AfterMatch[i,] = colMeans(X[controlZ,,drop=FALSE]); X.T.AfterMatch[i,] = colMeans(X[treatedZ,,drop=FALSE])"
"0","    nTreatedAfterMatch[i] = length(treatedZ)"
"0","  }"
"0","  stdDiff.After = apply( X.T.AfterMatch - X.C.AfterMatch,2,function(x){ sum(x * nTreatedAfterMatch) / sum(nTreatedAfterMatch)}) / overallSD"
"0","  stdDiff.After = abs(stdDiff.After)"
"0","  output = cbind(stdDiff.Before,stdDiff.After)"
"0","  colnames(output) = c(""Standardized differences before matching"",""Standardized differences after matching"")"
"0","  return(output)"
"0","}"
"0","##### effectSampleSize "
"0","### FUNCTION: computes the asymptotic variance of effectRatio estimator and the maximum strata size for effectratio estimator"
"0","### INPUT: Z: treatment/control vector (n time 1) "
"0","###        matchedNumber: vector of matches"
"0","### OUTPUT: a two-dimensional vector, the first dimension being the effective sample size and the second dimension being the maximum strata size."
"0","effectSampleSize <- function(Z,matchedNumber) {"
"0","  # Deal with non-matched individuals #"
"0","  Z.matchedIndiv = Z[!is.na(matchedNumber)]"
"0","  matchedNumber.matchedIndiv = matchedNumber[!is.na(matchedNumber)]"
"0","  "
"0","  # Sort individuals in ascending matching order"
"0","  matchedNumber.sortedIndex = sort(matchedNumber.matchedIndiv,index.return=TRUE)$ix"
"0","  Z.sorted = Z.matchedIndiv[matchedNumber.sortedIndex]"
"0","  matchedNumber.sorted = matchedNumber.matchedIndiv[matchedNumber.sortedIndex]"
"0","  "
"0","  # Calculate the size of each matched set and the corresponding weights"
"0","  ni = tabulate(matchedNumber.sorted); I = length(ni)"
"0","  ni.max = max(ni)"
"0","  asympVarEffectRatio = (sum(ni^3 / (ni - 1)) * 1/I) / (sum(ni) / I)^2"
"0","  print(paste(""Asymptotic variance of effect ratio estimator is"",asympVarEffectRatio))"
"0","  print(paste(""Maximmum strata size is"",ni.max))"
"0","  return(c(asympVarEffectRatio,ni.max))"
"0","}"
"0","### Index check function ###"
"0","# Do each pair have one treated?"
"0","# Check if true R, pair ID, and effect modifier values are retained "
"0","# after dropping individuals with NA for R and effect modifier."
"0","# Comparing known truth vs. questionable indexed after dropping NA."
"0","idxCheck <- function(truePersonID, trueDF, questionPersonID, questionDF) {"
"0","  truth <- data.frame(truePersonID, trueDF)  # collect key"
"0","  truth <- truth[order(truth$truePersonID),]  # order by ID"
"0","  question <- data.frame(questionPersonID, questionDF)  # collect df in question"
"0","  question <- question[order(question$questionPersonID),]  # order by ID"
"0","  # indices in truth where truePersonID is contained in questionPersonID"
"0","  idxTinQ <- which(truth$truePersonID %in% question$questionPersonID)"
"0","  # indices in question where questionPersonID is contained in truePersonID"
"0","  idxQinT <- which(question$questionPersonID %in% truth$truePersonID)"
"0","  if(length(idxTinQ) != length(idxQinT)) stop('index vectors length are differing...')"
"0","  "
"0","  # check if rowSums of boolean is equal to number of columns"
"0","  # boolean is whether elements are equal"
"0","  # unique to summarize"
"0","  fuck <- unique(rowSums(truth[idxTinQ,]==question[idxQinT,]) == dim(truth)[2])"
"0","  # if fuck is true then indexing seems good (thank fuck)"
"0","  # if fuck is true and false then indexing is fucked (oh fuck)"
"0","  # if fuck is just false then indexing is fucked (fuck)"
"0","  return(fuck)"
"0","}"
"0","##### ListCART: Run CART on abs(Y) on X from rpart on default settings for a list of outcomes "
"0","### FUNCTION: outputs list of CART trees from rpart on default settings"
"0","### INPUT: Z: instrument (n by 1 vector)"
"0","###        tableDF: data frame of the table of responses (n by r)"
"0","###        D: dose (n by 1 vector)"
"0","###        X: covariate matrix (n by p)"
"0","###        matchedNumber: matching vector from matching() function"
"0","###        null: the lambda_0 value in H0: lambda = lambda_0"
"0","### OUTPUT: list of CART trees from rpart on default settings"
"0","ListCART = function(Z,tableDF,D,X,matchedNumber,null = 0){"
"0","  "
"0","  if (class(tableDF) != ""data.frame""){tableDF = as.data.frame(tableDF)}"
"0","  "
"0","  "
"0","  tdfNA <- colnames(tableDF)[colSums(is.na(tableDF)) > 0]  # find which variables have missing values "
"0","  "
"0","  varsWithNA <- tableDF %>% dplyr::select(tdfNA)  # select missing variables"
"0","  "
"0","  # find rows where NA for outcome variable, get pair ID for those rows, "
"0","  # ignore pairs associated with that ID"
"0","  tdfNAid <- lapply(varsWithNA, function(x) which(is.na(x)))  # list of row indices of missingness"
"0","  pairID <- lapply(tdfNAid, function(x) matchedNumber[x])  # list of pair IDs where at least one pair has missing outcome"
"0","  idxPair <- lapply(pairID, function(x) which(matchedNumber %in% x))  # list of row indices of pairs corresponding to a missing outcome value"
"0","  "
"0","  cartList <- list()"
"0","  for (i in colnames(tableDF)) {"
"0","    if (sum(is.na(tableDF[c(i)])) > 0){"
"0","      Zcart=Z[-idxPair[[c(i)]]]"
"0","      Dcart=D[-idxPair[[c(i)]]]"
"0","      Rcart=tableDF[-idxPair[[c(i)]],c(i)]"
"0","      Xcart=as.matrix(X[-idxPair[[c(i)]],])"
"0","      matchedNumberCart = matchedNumber[-idxPair[[c(i)]]]"
"0","      "
"0","      # drop individuals who weren't matched"
"0","      uMatchedSetsCart = unique(matchedNumberCart[!is.na(matchedNumberCart)])  # guarantee no unmatched individuals"
"0","      "
"0","      # get absolute treated-minus-control differences and covariate matrix"
"0","      absY <- numeric(length(uMatchedSetsCart))"
"0","      Xi <- data.frame(matrix(0, ncol = dim(Xcart)[2], nrow ="
"0","                                length(uMatchedSetsCart)))"
"0","      for (j in 1:length(uMatchedSetsCart)) {"
"0","        pairR <- Rcart[which(matchedNumberCart==uMatchedSetsCart[j])]"
"0","        pairZ <- Zcart[which(matchedNumberCart==uMatchedSetsCart[j])]"
"0","        pairD <- Dcart[which(matchedNumberCart==uMatchedSetsCart[j])]"
"0","        augPairDiff <- pairR %*% pairZ - null * pairD %*% pairZ - "
"0","          (pairR %*% (1-pairZ) - null * pairD %*% (1-pairZ))"
"0","        absY[j] <- abs(augPairDiff)"
"0","        Xi[j,] <- colMeans(Xcart[which(matchedNumberCart =="
"0","                                         uMatchedSetsCart[j]),], na.rm=TRUE)"
"0","      }"
"0","      colnames(Xi) <- colnames(Xcart)"
"0","      #OHIEsurv <- data.frame(rank(absY), Xi)"
"0","      cartdf <- data.frame(absY, Xi)"
"0","      "
"0","      # regress rank of |Y| on X"
"0","      #emTree <- rpart(rank.absY.~., data=OHIEsurv)"
"0","      "
"0","      # regres |Y| on X"
"0","      emTree <- rpart(absY~., data=cartdf, model = TRUE)"
"0","    } else {"
"0","      Zcart=Z"
"0","      Rcart=tableDF[c(i)]"
"0","      Xcart=X"
"0","      Dcart=D"
"0","      matchedNumberCart = matchedNumber"
"0","      "
"0","      # drop individuals who weren't matched"
"0","      uMatchedSetsCart = unique(matchedNumberCart[!is.na(matchedNumberCart)])  # guarantee no unmatched individuals"
"0","      "
"0","      # get absolute treated-minus-control differences and covariate matrix"
"0","      absY <- numeric(length(uMatchedSetsCart))"
"0","      Xi <- data.frame(matrix(0, ncol = dim(Xcart)[2], nrow ="
"0","                                length(uMatchedSetsCart)))"
"0","      for (j in 1:length(uMatchedSetsCart)) {"
"0","        pairR <- Rcart[which(matchedNumberCart==uMatchedSetsCart[j])]"
"0","        pairZ <- Zcart[which(matchedNumberCart==uMatchedSetsCart[j])]"
"0","        pairD <- Dcart[which(matchedNumberCart==uMatchedSetsCart[j])]"
"0","        augPairDiff <- pairR %*% pairZ - null * pairD %*% pairZ - "
"0","          (pairR %*% (1-pairZ) - null * pairD %*% (1-pairZ))"
"0","        absY[j] <- abs(augPairDiff)"
"0","        Xi[j,] <- colMeans(Xcart[which(matchedNumberCart =="
"0","                                         uMatchedSetsCart[j]),], na.rm=TRUE)"
"0","      }"
"0","      colnames(Xi) <- colnames(Xcart)"
"0","      #OHIEsurv <- data.frame(rank(absY), Xi)"
"0","      cartdf <- data.frame(absY, Xi)"
"0","      "
"0","      # regress rank of |Y| on X"
"0","      #emTree <- rpart(rank.absY.~., data=OHIEsurv)"
"0","      #rpart.plot(emTree)"
"0","      "
"0","      # regres |Y| on X"
"0","      emTree <- rpart(absY~., data=cartdf, model = TRUE)"
"0","    }"
"0","    cartList[[i]] <- emTree"
"0","  }"
"0","  return(cartList)"
"0","}"
